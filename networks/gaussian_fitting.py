#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Oct 28 02:19:05 2019

@author: liqinying
"""

import torch
import torch.nn as nn

#NO NUMPY

class gaussian_fit(nn.Module):
   def __init__(self, activation_maps):
    super(gaussian_approx, self).__init__()
 
   def forward(self, x):
    #x would be the activation maps generated by pose encoder
    """np_x=x.detach().numpy() # convert to numpy array to compute covariance
    np_x_dim=np_x.shape
    print("np_x_fim")
    print(np_x_dim)
    
    assert len(np_x_dim) ==4, "The input is a {}-tensor".format(str(np_x_dim))
    mu=np.mean(np_x,(2,3))
    #print("mu")
    #print(mu)
"""
    x_shape=list(x.size())
    assert x_shape.size()==4, "input is not a 4-tensor"
    
    mu=x.mean(2)
    mu=mu.mean(3)
    """
    #print("np_x")
    #print(np_x)
    ones=np.ones_like(np_x[0][0], dtype=float)

    #print("np_x[0].shape")
    #print(np_x[0].shape)
    """
    ones=torch.empty(x_shape[0], x_shape[1],x_shape[2], x_shape[3], dtype=torch.float)
    covs=torch.empty(x_shape[0], x_shape[1],x_shape[2], x_shape[3], dtype=torch.float)
    inv_conv=torch.empty(x_shape[0], x_shape[1],x_shape[2], x_shape[3], dtype=torch.float)
    ones.fill(1.)
    
    mu_tensor=ones
    for i in range(x_shape[0]):
      mu_tensor[i]*=mu[i].item()
      for j in range(x_shape[1]):
        x[i][j]=torch.sum(x[i][j])
        covs[i][j]=cov(x[i][j])
        inv_conv[i][j]=covs.inverse()
    #aferf
    """
    mu_matrix=np.asarray([[mu[i][j]*ones for j in range(np_x_dim[1])]for i in range(np_x_dim[0])], dtype=float)
    print("mu_matrix")
    print(mu_matrix)

    cov=np.asarray([[np.cov(activ) for activ in np_x[i]] for i in range(np_x_dim[0])],dtype=float)
    #print("cov")
    #print(cov)
"""
   #ghsrthg 
    """
    epsilon=np.random.rand(cov.shape[0], cov.shape[1],cov.shape[2],cov.shape[3])/1e8
    cov+=epsilon
    #print("cov after adding epsilon")
    #print(cov)
    cov_inv=np.asarray([[np.linalg.inv(cov_mat) for cov_mat in cov[i]]for i in range(np_x_dim[0])], dtype=float)
    

    assert cov_inv.shape==np_x.shape and np_x.shape==mu_matrix.shape, "matrices do not have the same shape!"
    """
    #gserg

    """
    #print("np_x-mu_matrix")
    #print(np_x-mu_matrix)
    print(np.matmul(np_x[i][j]-mu_matrix[i][j], cov_inv[i][j]))
    matrix=np.asarray([[
            np.matmul(np.matmul(np_x[i][j]-mu_matrix[i][j], cov_inv[i][j]),(np_x[i][j]-mu_matrix[i][j]))\
            for j in range(np_x_dim[1])
            ] for i in range(np_x_dim[0])])
    print("matrix")
    print(matrix)
    assert matrix.shape==np_x_dim, "matrix has the wrong shape!?"
"""
    output=np.ones_like(np_x)
    for i in range(np_x_dim[0]):
      for j in range(np_x_dim[1]):
        for k in range(np_x_dim[2]):
          for l in range(np_x_dim[3]):
            output[i][j][k][l]=1./(1.+matrix[i][j][k][l])

    output_tensor=torch.from_numpy(output).float()
    return output
    
    @static_method
    def cov(t):
      def cov(t):
      t_exp=torch.mean(t, dim=1).double()
      print(t_exp)
      t_norm=(t-t_exp[:, None]).double()
      
      one=1.
      covariance=one/(t.size(1)-one)*t_norm.mm(t_norm.t())
      return covariance.double()